---
title: "ggplot2 aesthetics worksheet"
author: "Monica Thieu"
date: "7/6/2021"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(tidyverse)
require(learnr)
tutorial_options(exercise.eval = TRUE)
watermark <- function (x, y) {
  annotate("text",
           x = x, y = y,
           label = "EXAMPLE!",
           size = rel(10),
           color = "firebrick",
           angle = -45,
           alpha = 0.8)
}
```

## Intro

This interactive worksheet will walk you through a series of mini-challenges designed to demonstrate **some of the many aesthetic adjustments you can make to a `ggplot2` graph for readability and pizzazz.**

The exercises below heavily reference the [official ggplot2 textbook](https://ggplot2-book.org/index.html). The textbook is not a cookbook for producing any type of plot, but I recommend it to any R users looking to gain first-principles fluency with ggplot2's design philosophy and how its features are structured.

Similarly, this worksheet does not demonstrate *every* possible ggplot aesthetic modification (and you really can adjust nearly every feature of a plot with `ggplot2`!). The worksheet walks through common aesthetic changes I find myself using in my own plots, that I hope will apply to your plotting needs as well.

------------------------------------------------------------------------

The exercises below assume a general comfort with adjusting `ggplot2` code by adding new layers and changing the arguments specified within existing layers.

In particular, some exercises will provide a pre-coded base plot stored in a variable, and ask you to to add layers to the plot in that variable.

Other exercises will ask you to adjust the base code for a plot in order to change its appearance. (If you see the full base code written out in an exercise chunk, that's your first hint that you will need to alter the code provided!)

Remember that constructing a whole multi-layered ggplot in one call is roughly equivalent to constructing the base layers of that plot, assigning the plot to a variable, and then adding another element to that variable. So these two chunks should produce identical plots:

```{r, echo = TRUE}
# Building the whole plot at once
iris %>% 
  ggplot(aes(x = Species, y = Petal.Length, fill = Species)) +
  geom_boxplot() + 
  theme_bw()
```

```{r, echo = TRUE}
# Building just the base layers, storing in variable
plot_iris <- iris %>% 
  ggplot(aes(x = Species, y = Petal.Length, fill = Species)) +
  geom_boxplot()

# Calling the base plot via variable, then adding layer(s)
plot_iris + theme_bw()
```

In this worksheet, you can assume the following:

-   When a base plot variable is provided in an exercise chunk, you *will not* need to edit the base plot to complete that exercise. You will only need to add new layers
-   The code that creates base plots will always be displayed in a read-only chunk for your reference
-   When raw `ggplot2` code is provided in an exercise chunk, you *will* need to edit the base plot to complete that exercise. You may *also* need to add new layers, but not necessarily

Finally, remember that because of `ggplot2`'s modular, layered structure, almost all of the aesthetic changes demonstrated in this worksheet can be mixed and matched with each other in a single plot to customize as much as you would like. These exercises mostly show the adjustments one at a time for simplicity, but you can (and should) combine them in your own plots!

## Modifying titles of plot elements

The default axis/legend title in `ggplot2` is the name of the variable displayed on that axis/legend. While you yourself will know what these variable names mean in your data, in any graph that you will ever show to another person, you will want to re-label axes/legends and add a title to make your plot more readable. `ggplot2` comes with an all-purpose function, `labs()`, that will allow you to edit the titles of pretty much any plot element (and figure captions).

To illustrate this, we will look at the `iris` dataset collected by botanist Edgar Anderson (1935), which measures the flower dimensions of several exemplars of 3 iris species.

Use the `labs()` function as demonstrated in [Section 8.1](https://ggplot2-book.org/annotations.html#titles) of the textbook to add the following titles shown below on the solution plot:

-   x-axis: "Iris species"
-   y-axis: "Petal length (cm)"
-   legend for fill color: "species"
-   plot title: "Iris petal length by species"
-   plot subtitle: "Three species"

Hint: You only need to call `labs()` once to set all of these labels.

```{r make-plot-iris, echo = TRUE}
plot_iris <- iris %>% 
  ggplot(aes(x = Species, y = Petal.Length, fill = Species)) +
  geom_boxplot()
```

```{r}
plot_iris +
  labs(x = "Iris species",
       y = "Petal length (cm)",
       fill = "species",
       title = "Iris petal length by species",
       subtitle = "Three species") +
  watermark(2, 4)
```

```{r add-labs, exercise = TRUE}
plot_iris
```

## Modifying axis labels of discrete variables

Sometimes, in addition to editing axis titles, you will also want to edit the level labels of a discrete variable to improve readability. For example, if you have a binary gender variable coded as "F" and "M" plotted on one axis, you may want to have the plot say "Female" and "Male" instead.

Use the function & argument demonstrated in [section 10.3.2](https://ggplot2-book.org/scale-position.html#scale-labels) of the textbook to change the labels of the iris species to their common names (per Wikipedia) instead of their taxonomic names:

-   Iris setosa -\> "Bristle-pointed iris"
-   Iris virginica -\> "Virginia iris"
-   Iris versicolor -\> "Blue flag iris"

Hint: In the example graph, the discrete labels are on the y-axis, but in this graph, the discrete labels are on the x-axis.

```{r make-plot-iris-labeled}
plot_iris_labeled <- plot_iris +
  labs(x = "Iris species",
       y = "Petal length (cm)",
       fill = "species",
       title = "Iris petal length by species",
       subtitle = "Three species")
```

```{r}
plot_iris_labeled +
  scale_x_discrete(labels = c("setosa" = "Bristle-pointed iris",
                              "virginica" = "Virginia iris",
                              "versicolor" = "Blue flag iris"))
```

```{r change-axis-label-text, exercise = TRUE, exercise.setup = "make-plot-iris-labeled"}
plot_iris_labeled
```

## Modifying axis label appearance for readability

When plotting a discrete variable along one axis (in these examples, the x-axis), it often makes sense to change the order of variable levels along that axis so that the order of variables along the axis adds meaning to the plot.

To illustrate this more clearly, let's look at a different dataset now: the area (in square miles) of the 50 US states. This dataset helps illustrate the benefits of the next few techniques, in particular because it has a *lot* of levels (50!) of a discrete variable.

```{r make-us-states-by-area}
us_states_by_area <- tibble(state = datasets::state.name,
                            abbrev = datasets::state.abb,
                            area = datasets::state.area,
                            region = datasets::state.region,
                            division = datasets::state.division)
```

First, we'll plot a lollipop plot with state on the x-axis, and area on the y-axis. With this plot style, we can reap the benefits of both bar graphs and point graphs for visualizing magnitude data like state areas. (The lines help illustrate the magnitude of each state's area, like a bar graph, but the skinniness of the lines and the "lollipop" points on top of each line make it easier to compare the area of each state than it would be comparing wide bars on a bar graph.)

```{r make-plot-us-states-by-area}
plot_us_states_by_area <- us_states_by_area %>% 
  ggplot(aes(x = state, y = area)) + 
  # the stick of the lollipop
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  # the candy of the lollipop
  geom_point()
```

```{r}
plot_us_states_by_area
```

The state names along the x-axis are unreadable because they are written on top of each other! Next, we'll practice a few techniques for adjusting the axis labels for levels of a discrete variable that specifically mitigate overplotted labels like these.

### Rotating axis labels

Use one of the functions demonstrated in [section 10.3.3](https://ggplot2-book.org/scale-position.html#guide_axis) of the textbook to rotate the axis labels for the state names by 45 degrees counter-clockwise. (The labels should appear to be right-justified to the axis.) 

```{r}
plot_us_states_by_area_angled <- plot_us_states_by_area + 
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  watermark(25, 3e5)

plot_us_states_by_area_angled
```

```{r axis-label-rotate-ccw, exercise = TRUE, exercise.setup = "make-plot-us-states-by-area"}
plot_us_states_by_area
```

Now, use the same function to rotate the axis labels for the state names by 45 degrees clockwise instead. (The labels should appear to be left-justified to the axis.) 

```{r}
plot_us_states_by_area +
  scale_x_discrete(guide = guide_axis(angle = -45)) + 
  watermark(25, 3e5)
```

```{r axis-label-rotate-cw, exercise = TRUE, exercise.setup = "make-plot-us-states-by-area"}
plot_us_states_by_area
```

### Dodging axis labels

Now, use another function demonstrated in section "dodge" the axis labels by a factor of 5 so that state name labels are jittered into 5 rows.

```{r}
plot_us_states_by_area + 
  scale_x_discrete(guide = guide_axis(n.dodge = 5)) +
  watermark(25, 3e5)
```

```{r axis-label-dodge, exercise = TRUE, exercise.setup = "make-plot-us-states-by-area"}
plot_us_states_by_area
```

As you can see, for these data, dodging into as many as 5 rows still doesn't fully stop the state names from plotting on top of one another, and it's hard to tell which lollipops the labels in the lower rows are referring to. For this reason, I usually prefer rotating axis labels over dodging them, but either might be the best choice depending on the plot. We'll use counterclockwise-rotated axis labels for the rest of the plots in this section.

## Reordering levels of a discrete variable

From our current plot, we can get information about smaller and larger states, but the order is not very sensible. To see the very largest states, a graph reader can go to the tallest lollipops and then look down to the axis label, but they have to jump around from lollipop to lollipop because the states are ordered alphabetically along the x-axis, not by area.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = state, y = area)) + 
  # the stick of the lollipop
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  # the candy of the lollipop
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(title = "Could be a bit easier to follow...")
```

Use the function demonstrated in the [forcats package vignette: Ordering by another variable](https://forcats.tidyverse.org/articles/forcats.html#ordering-by-another-variable-1) to reorder the states along the x-axis by area from smallest to largest.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  watermark(25, 3e5)
```

```{r fct-reorder, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = state, y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45))
```

Now, refer to the function's [docs](https://forcats.tidyverse.org/reference/fct_reorder.html) and use another argument to flip the reordering, so the states are ordered from largest to smallest instead.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area, .desc = TRUE), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  watermark(25, 3e5)
```

```{r fct-reorder-desc, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = state, y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45))
```

Bonus exercise: Since the x-axis label looks pretty gnarly now because of the code used to reorder states along the x-axis by their area, and we should re-label axes and title our plot anyway, use `labs()` to relabel the plot of US states by area to match the solution plot below.

```{r make-plot-us-states-ang-reo, echo = TRUE}
plot_us_states_by_area_angled_reordered <- us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45))
```

```{r}
plot_us_states_by_area_angled_reordered
```

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area, .desc = TRUE), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  watermark(25, 3e5) +
  labs(x = "US state",
       y = "Area (sq mi)",
       title = "Alaska is really big")
```

```{r labs-fct-reorder-desc, exercise = TRUE, exercise.setup = "make-plot-us-states-ang-reo"}
plot_us_states_by_area_angled_reordered
```

## Adjusting continuous axis limits

Since the last few exercises demonstrated aesthetic adjustments you might make to discrete variables, next we'll look at some adjustments you might make on continuous variables.

Right now, we'll pivot back to the iris flower size plot from the beginning of the worksheet. We'll now turn to adjusting aesthetics along the y-axis, representing the continuous variable of iris petal length in centimeters.

```{r make-plot-iris-lab-common, echo = TRUE}
plot_iris_labeled_commonname <- plot_iris_labeled +
  scale_x_discrete(labels = c("setosa" = "Bristle-pointed iris",
                              "virginica" = "Virginia iris",
                              "versicolor" = "Blue flag iris"))
```

```{r}
plot_iris_labeled_commonname
```

### Expanding axis limits to include a certain value

`ggplot2`, like most plotting software, automatically sets the axis limits of a graph based on the range of the data. However, careful plotters know that axis limits must be selected carefully as to faithfully represent the effect sizes present in the data!

One common axis limit change you might make is to expand limits to include 0. If you have a variable for which 0 carries meaning, it can be helpful to see where 0 is relative to your data.

Referring to the function [docs](https://ggplot2.tidyverse.org/reference/expand_limits.html), use the `ggplot2` function `expand_limits()` to show 0 on the y-axis.

```{r}
plot_iris_labeled_commonname +
  expand_limits(y = 0) +
  watermark(2, 3.5)
```

```{r expand-limits, exercise = TRUE, exercise.setup = "make-plot-iris-lab-common"}
plot_iris_labeled_commonname
```

One big benefit of `expand_limits()` is that you don't need to know anything about the actual range of your data. You just have to tell the function what value you want to include on the axis, and your ggplot will show that number as well as the rest of your data.

### Changing axis limits to preset bounds

Sometimes, you may want to change your axes to "zoom" your plot to a specific range of values. You may want to zoom in (to stop showing outliers), or to zoom out to meaningful start and end bounds.

Referring to [section 10.1.2](https://ggplot2-book.org/scale-position.html#oob) of the textbook, use the "zooming" limit adjustment function (NOT the one that will trim data if they fall outside of the limits!) to change the y-axis bounds to 0 on the lower end and 8 on the higher end.

```{r}
plot_iris_labeled_commonname +
  coord_cartesian(ylim = c(0, 8)) +
  watermark(2, 3.5)
```

```{r coord-cartesian-limits, exercise = TRUE}
plot_iris_labeled_commonname
```

## Scaling continuous axes

Sometimes, you don't want to edit the bounds of a continuous axis, but you do need to change its scaling.

To illustrate this use case more clearly, we'll step away to a different dataset: the vital characteristics of key Star Wars characters from the 9 movies in the Skywalker saga. Here, we'll focus on plotting a histogram of characters' masses in kilograms (yes, apparently they use the metric system in a galaxy far, far away).

```{r make-plot-starwars-mass}
plot_starwars_mass <- starwars %>% 
  filter(!is.na(mass)) %>% 
  ggplot(aes(x = mass)) +
  geom_histogram(bins = 30) +
  labs(x = "Character mass (kg)",
       y = "Number of characters",
       title = "Histogram of Star Wars characters' masses",
       subtitle = "Episodes I-IX")
```

```{r}
plot_starwars_mass
```

Jabba the Hutt is far and away the heaviest character (all that organized crime pays for a very luxurious diet), which is pushing all of the lighter characters into just a few histogram bins.

To address this, use one of the convenience functions demonstrated in [section 10.1.9](https://ggplot2-book.org/scale-position.html#scale-transformation) of the textbook to show x-axis tick labels on the log-10 scale.

```{r}
plot_starwars_mass +
  scale_x_log10() +
  watermark(150, 10)
```

```{r scale-x-log10, exercise = TRUE, exercise.setup = "make-plot-starwars-mass"}
plot_starwars_mass
```

I like this method of axis scaling when possible because it shows the axis ticks at log-distance from each other, but still has the axis tick labels in real units, not log-transformed units.

## Altering continuous axis breaks 

This histogram of Star Wars' characters' masses is also useful to illustrate situations where you might want to change the values at which grid lines appear along a continuous axis. I might do this if a histogram has short enough bins that some of the default y-axis grid lines occur at fractional values. Fractional grid lines aren't useful for count variables (you can't have 0.5 of an observation), so it's handy to adjust grid lines in that case.

For example, along the y-axis of the histogram of Star Wars' characters' masses, the minor (non-numbered) y-axis grid lines appear to occur between the 5s and the 0s. There will never be 2.5 people in any of the bins, so we'll try a few different strategies to change where the grid lines hit so they only hit round numbers.

### Set axis break width

First, use `scales::breaks_width()` to set the major breaks to occur on the 10s, as shown in [section 10.1.5](https://ggplot2-book.org/scale-position.html#break-functions) of the textbook.

```{r make-plot-starwars-mass-log10, echo = TRUE}
plot_starwars_mass_log10 <- plot_starwars_mass +
  scale_x_log10()
```

```{r}
plot_starwars_mass +
  scale_x_log10() +
  scale_y_continuous(breaks = scales::breaks_width(10)) +
  watermark(150, 10)
```

```{r breaks-width, exercise = TRUE, exercise.setup = "make-plot-starwars-mass-log10"}
plot_starwars_mass_log10
```

### Set number of major breaks

Next, use `scales::breaks_extended()` to redraw the y-axis grid lines with 12 major grid lines, as demonstrated in the same textbook section as the previous exercise.

```{r}
plot_starwars_mass +
  scale_x_log10() +
  scale_y_continuous(breaks = scales::breaks_extended(n = 12)) +
  watermark(150, 10)
```

```{r breaks-n, exercise = TRUE, exercise.setup = "make-plot-starwars-mass-log10"}
plot_starwars_mass_log10
```

### Manually set break values

Next, use `seq()` (NOT a `ggplot2` smart-breaks function!) to create a vector stepping from 0 to 20 in steps of 4 to manually draw the y-axis major breaks at 0, 4, 8 ... 20.

Hint: This will be a little different than the previous two, but if you had to guess how the code would look, try that!

Hint 2: You will need to manually assign the vector to the `breaks` argument of `scale_y_continuous`.

```{r}
plot_starwars_mass +
  scale_x_log10() +
  scale_y_continuous(breaks = seq(0, 20, 4)) +
  watermark(150, 10)
```

```{r breaks-manual, exercise = TRUE, exercise.setup = "make-plot-starwars-mass-log10"}
plot_starwars_mass_log10
```

## Changing colors of data elements

In this section, we'll practice modifying the color schemes used to plot data information by color. While the default R data color schemes do the job decently well for quick exploratory graphs, changing the color scheme allows you to personalize your plots almost instantly.

For these exercises, we will turn back to the lollipop plot of US states by area in square miles. 

### Applying pre-made color schemes

R comes with some built-in alternative color scheme functions for you to apply pre-made color schemes carefully designed to help viewers spot patterns in data.

For discrete (ordered or non-ordered) data, R has palettes from [ColorBrewer](https://colorbrewer2.org/), a palette set designed for plotting discrete colors onto maps.

In the exercise below, modify the base plotting call so that lollipop color (both the line-segment sticks and the point candies) varies with the discrete variable `region` in the data, and set the color scheme to use ColorBrewer with palette "Dark2". (Note that this palette is appropriate for un-ordered categorical variables like the `region` variable here.)

Refer to [section 11.3.1](https://ggplot2-book.org/scale-colour.html#brewer-scales) of the textbook.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = region)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r change-data-color-brewer, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

Next, we will try out another pre-made color scheme, this time for continuous data. The [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) color map set was originally made for Python's matplotlib package, but has since been ported to R as well. The viridis color maps were designed to show continuously varying data in an attractive, colorblind-safe, and perceptually uniform way.

In the exercise below, modify the base plotting call so that lollipop color varies with `area` in the data (yes, area is also plotted on other axes, so when done correctly, the lollipops should get lighter from left to right because color will be confounded with x-axis position and lollipop height). Additionally, set the color scheme to use viridis (for continuous data) with palette option "inferno".

Refer to [section 11.2.1](https://ggplot2-book.org/scale-colour.html#particular-palettes) of the textbook.

Hint: There are a couple versions of the viridis color scale functions in `ggplot2`. Be sure to use the one for _continuous_ data.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_viridis_c(option = "inferno") +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r change-data-color-viridis, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

### Applying custom color schemes

If you want to fully customize your plot colors, you may choose to select your own color scheme. You can do this too! Bear in mind that colors you select may not have the same perceptual properties as pre-made color schemes, but if your colors have some significance (matching the colors of your institution, for example) they should still look nice.

`ggplot2` understands a series of pre-specified named colors, shown [here](http://sape.inf.usi.ch/quick-reference/ggplot2/colour), or hex color codes.

First, you can wholesale change the color of data elements, even when color isn't mapped to a variable. The default color of lines and points on a graph is black, but can be set to any single color you please.

In the exercise below, set the line segments to the constant hex color "#825324", and set the points to the constant named color "forestgreen". The lollipops should look like very skinny trees.

Refer to [sections 14.4.1 and 14.4.2](https://ggplot2-book.org/layers.html#plots-and-layers) of the textbook for help with this, especially in differentiating where in the functions the color argument should be specified to have the desired behavior.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area), color = "#825324") +
  geom_point(color = "forestgreen") +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r change-data-color-manual-constant, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

Next, we'll go back to customizing the color scales used for differentiating data by color. In the exercise below, use `scale_color_manual()` to specify a custom discrete color scale for the `region` variable with the following regions mapped to the following colors:

* Northeast: "firebrick"
* South: "navyblue"
* North Central (I think this refers to the Midwest actually): "lightpink"
* West: "skyblue"

Refer to [section 11.3.3](https://ggplot2-book.org/scale-colour.html#manual-scales) of the textbook.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = region)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_manual(values = c("Northeast" = "firebrick",
                                "South" = "navyblue",
                                "North Central" = "lightpink",
                                "West" = "skyblue")) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r change-data-color-manual-discrete, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

In the exercise below, use `scale_color_gradient()` to set `area` to vary with a custom unidirectional color gradient going from "#000000" on the low end to "#ff3dab" on the high end.

Refer to [section 11.2.2](https://ggplot2-book.org/scale-colour.html#robust-recipes) of the textbook. You may need to scroll down a little bit for examples.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_gradient(low = "#000000", high = "#ff3dab") +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r change-data-color-manual-cont, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

### Rescaling continuous color variables

When color is mapped to a continuous variable, by default, the lowest color on the palette is assigned to the minimum of the variable, and the highest color on the palette is assigned to the maximum. If data are relatively evenly distributed between the min and the max, this looks reasonable. However, if the data are super skewed, this can skew the visible range of the color scale so that the outlier values look very different in color, and all the other values look like the same color.

We can see this happening in our plot of US states by area, because Alaska is _so_ big that it's pushing the top of the color scale up, causing all the other states to look like they fall at the bottom of the color scale.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_viridis_c(option = "inferno") +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

By setting some arguments in `scale_color_viridis_c()` (or whatever continuous color scale function is being applied), we can manually set bounds on the color scale, and tell `ggplot2` to plot any values outside the bounds at the min or max color respectively. This behavior is called "squishing" the color scale.

In the exercise below, add arguments at the beginning of `scale_color_viridis_c()` to set the color scale min to 0, the max to 200,000 (a bit smaller than Texas--this will set the biggest 2 states to be "squished" to the max color), and the out-of-bounds behavior to `scales::squish` to actually squish the values, as opposed to graying out the two biggest states. 

Refer to [section 10.1.2](https://ggplot2-book.org/scale-position.html?q=oob#oob) of the textbook for an example, although this section isn't strictly dedicated to handling skewed color scales.

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area, color = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  scale_color_viridis_c(limits = c(0, 2e5), oob = scales::squish, option = "inferno") +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r data-color-squish, exercise = TRUE, exercise.setup = "make-us-states-by-area"}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "area (sq mi)",
       title = "Alaska is really big")
```

In my field of cognitive neuroscience, I use this functionality when plotting statistics on brain images, if one brain region's value is so high that it's skewing the color scale for the rest of the regions. You might find it useful in another context, but it's good to know how to do!

## Annotating plots

In this brief section, we'll practice placing annotations on plots. If you want to label a specific feature of your data, or otherwise manually add clarifying information on your plot, here are some techniques.

For these exercises, we can stick with the plot of US states by area we've been using.

```{r make-plot-us-states-ang-reo-lab}
plot_us_states_by_area_angled_reordered_labeled <- us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "Area (sq mi)",
       title = "Alaska is really big")
```

```{r}
plot_us_states_by_area_angled_reordered_labeled
```

### Drawing reference lines

Often,  it is useful to compare data on a plot to a particular reference value. This value can be 0, if it's not obvious on the plot, or some other meaningful number. Drawing a reference line at values of interest allows readers to make quicker visual comparisons.

For example, we might like to compare the area of US states to the area of a specific other country. (The US is so big that many individual states are larger than other sovereign nations in the world.)

In this exercise, use `geom_hline()` to place a dashed horizontal reference line across the graph at 57,321 sq mi, the area of Bangladesh. Set the color of this line to "springgreen4".

Refer to [section 8.3](https://ggplot2-book.org/annotations.html#custom-annotations) of the textbook for an example (though the example uses a vertical line instead of a horizontal one, the arguments are very similar), and to the relevant function [docs](https://ggplot2.tidyverse.org/reference/geom_abline.html) for more information on what arguments `geom_hline()` takes.

```{r}
plot_us_states_by_area_angled_reordered_labeled +
  geom_hline(yintercept = 57321, linetype = "dashed", color = "springgreen4") +
  watermark(25, 3e5)
```

```{r hline, exercise = TRUE, exercise.setup = "make-plot-us-states-ang-reo-lab"}
plot_us_states_by_area_angled_reordered_labeled
```

Notice how the reference line is drawn on top of the lollipops? This is a direct result of the order in which the plot was constructed. The layers for the lollipop parts (the line segments and the points) were set before the reference line was added, so they are plotted below the reference line. By changing the order in which the layers are added on the plot, we can draw the reference line first, so that the lollipops are drawn on top (and are easier to see).

In the exercise below, alter the order of the layers in the plot construction code to draw the reference line beneath the lollipops (under both the line segments and the points).

```{r}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_hline(yintercept = 57321, linetype = "dashed", color = "springgreen4") +
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "Area (sq mi)",
       title = "Alaska is really big") +
  watermark(25, 3e5)
```

```{r hline-beneath, exercise = TRUE}
us_states_by_area %>% 
  ggplot(aes(x = fct_reorder(state, area), y = area)) + 
  geom_segment(aes(xend = state, y = 0, yend = area)) +
  geom_point() +
  scale_x_discrete(guide = guide_axis(angle = 45)) +
  labs(x = "US state",
       y = "Area (sq mi)",
       title = "Alaska is really big") +
  geom_hline(yintercept = 57321, linetype = "dashed", color = "springgreen4")
```

(For other types of reference lines, `geom_vline()` draws vertical lines, and `geom_abline()` draws diagonal lines of any slope, but we won't use those in this worksheet.)

### Adding text labels



## Changing overarching theme

In this last set of exercises, we'll practice modifying theme elements, or all the "background" non-data pieces, of plots. This allows you to customize the overall look of your plots.

For these exercises, we'll plot one last dataset: the [Datasaurus](https://www.autodesk.com/research/publications/same-stats-different-graphs) dataset. The Datasaurus dataset features a series of points that all have the same descriptive statistics (mean, standard deviation, etc.) but have very different distributions that are apparent upon visualization. The namesake distribution is... a T-rex!

```{r make-plot-datasaurus}
plot_datasaurus <- datasauRus::datasaurus_dozen_wide %>% 
  ggplot(aes(x = dino_x, y = dino_y)) +
  geom_point() +
  labs(title = "Rawr!",
       subtitle = "Datasaurus says: always visualize your data.")
```

```{r}
plot_datasaurus
```

Since the data on a graph don't strictly influence theme aesthetic decisions, this will be a fun plot to customize without worrying what the data mean.

First, we'll apply some pre-made plot themes. `ggplot2`'s default white-on-gray theme looks classic, but if you prefer different background-grid-axis designs, you may choose to apply an alternate theme. (Or you might just want to choose a non-default theme for the sake of it. That's fine too!)

Refer to [section 18.2](https://ggplot2-book.org/polishing.html#themes) of the textbook for a list of `ggplot2`'s built-in themes.

In this exercise, add a theme command to render the Datasaurus plot in `ggplot2`'s built-in theme that features a white plot background, gray grid lines, and black borders.

```{r}
plot_datasaurus +
  theme_bw() +
  watermark(60, 50)
```

```{r theme-bw, echo = TRUE, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

In this exercise, add a theme command to render this plot in `ggplot2`'s "minimal" theme.

```{r}
plot_datasaurus +
  theme_minimal() +
  watermark(60, 50)
```

```{r theme-minimal, echo = TRUE, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

In this exercise, add a theme command to render this plot in `ggplot2`'s "classic" theme (designed to look like base R's default plots).

```{r}
plot_datasaurus +
  theme_classic() +
  watermark(60, 50)
```

```{r theme-classic, echo = TRUE, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

## Modifying text aesthetics

From this section to the end, we will be adjusting the appearance of specific theme elements. These exercises will demonstrate changing a selection of theme elements, but will not comprise an exhaustive list of every modifiable theme element. For that, refer to [section 18.4](https://ggplot2-book.org/polishing.html#theme-elements) of the textbook.

`ggplot2` provides a series of **element functions** that allow you to customize the appearance of theme elements. There are three families of theme elements: for _text, line, and rectangle._ Each element function takes a series of arguments specific to that type of element. For example, only `element_text()` takes an argument for font family, while only `element_rect()` takes an argument for fill color.

In this group of exercises, we will practice customizing text elements using `element_text()`.

### Changing text color

In the exercise below, change the color of _all_ text elements on the plot to "chartreuse4".

Refer to [section 18.3](https://ggplot2-book.org/polishing.html#modifying-theme-components) for examples of how to use the various arguments of `theme()` to adjust their respective theme elements, and to the [docs](https://ggplot2.tidyverse.org/reference/theme.html) for `theme()` to identify which theme element should be modified.

Hint: There is a single `theme()` argument that will modify every single text element in the graph.

```{r}
plot_datasaurus +
  theme(text = element_text(color = "chartreuse4")) +
  watermark(60, 50)
```

```{r change-text-color-all, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

In the exercise below, change the color of *just* the plot title to "chartreuse4".

Refer to the docs for `theme()` again to find the correct theme element argument to modify.

```{r}
plot_datasaurus +
  theme(plot.title = element_text(color = "chartreuse4")) +
  watermark(60, 50)
```

```{r change-text-color-title, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

### Changing fonts

In this exercise, change all the text on the plot to use the font Comic Sans MS.

```{r}
plot_datasaurus +
  theme(text = element_text(family = "Comic Sans MS"))
```

```{r change-font, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

In this exercise, change all the text to Comic Sans MS font (again), _and_ change the plot's subtitle to appear in **bold** font face.

```{r}
plot_datasaurus +
  theme(text = element_text(family = "Comic Sans MS"),
        plot.subtitle = element_text(face = "bold"))
```

```{r change-font-bold, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

### Changing text size

Use `rel()` to make the axis tick labels (on both axes) appear 2x as big as its usual "parent" size.

```{r}
plot_datasaurus +
  theme(axis.text = element_text(size = rel(2)))
```

```{r change-text-size, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

## Modifying grid line aesthetics

In the next set of exercises, we will practice modifying grid line aesthetics using `element_line()`.

### Changing grid line color

In this exercise, change the color of _all_ grid lines on the plot to "deeppink".

```{r}
plot_datasaurus +
  theme(panel.grid = element_line(color = "deeppink")) +
  watermark(60, 50)
```

```{r change-grid-color-all, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

In this exercise, change the color of the major (thicker) grid lines to "deeppink", and the minor (thinner) grid lines to "lightpink".

```{r}
plot_datasaurus +
  theme(panel.grid.major = element_line(color = "deeppink"),
        panel.grid.minor = element_line(color = "lightpink")) +
  watermark(60, 50)
```

```{r change-grid-color-sep, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

Next, we'll use a slightly different technique. In this exercise, use `element_blank()` to _remove_ all grid lines on the plot. (They aren't really relevant because we're plotting a dinosaur anyway.)

`element_blank()` can be assigned to any argument of `theme()` to make that element disappear on the graph.

```{r}
plot_datasaurus +
  theme(panel.grid = element_blank()) +
  watermark(60, 50)
```

```{r rm-grid, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

## Modifying background (rectangle) aesthetics

In this set of exercises, we will practice modifying the background of the plotting panel (the rectangle in which the data live) and the background of the entire plot (where the title, legend, and axis labels live). These elements are rectangles, governed by `element_rect()`.

### Changing inner plot background color

In this exercise, change the background of the plot panel (the square with the data in it, not the background where the title/axis labels are printed) to the fill color "skyblue".

```{r}
plot_datasaurus +
  theme(panel.background = element_rect(fill = "skyblue")) +
  watermark(60, 50)
```

```{r change-bg-color-panel, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

### Changing full background color

In this exercise, change the background of the entire plot (the background where the title/axis labels are printed) to the fill color "skyblue".

```{r}
plot_datasaurus +
  theme(plot.background = element_rect(fill = "skyblue")) +
  watermark(60, 50)
```

```{r change-bg-color-plot, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

### Modifying panel border

In this exercise, change the the border of the panel background (the panel containing the data) to the color "navyblue", and use `rel()` to set the border thickness to 2 times the parent size.

```{r}
plot_datasaurus +
  theme(panel.background = element_rect(color = "navyblue", size = rel(2))) +
  watermark(60, 50)
```

```{r change-plot-border-color, exercise = TRUE, exercise.setup = "make-plot-datasaurus"}
plot_datasaurus
```

## Modifying legend aesthetics

In this final set of exercises, we will modify plot legend aesthetics. Legends have some special `theme()` arguments allowing them to be moved around the plot, and the background of the legend box can also be customized using `element_rect()`.

First, we need to add a legend to our Datasaurus, by mapping some other variable to an aesthetic like color, point size, or point transparency. Since color changes just look nice, let's map `dino_x` to point color as well as x-axis position to create the effect of the dino getting lighter from left to right.

```{r make-plot-datasaurus-legend, echo = TRUE}
plot_datasaurus_legend <- datasauRus::datasaurus_dozen_wide %>% 
  ggplot(aes(x = dino_x, y = dino_y, color = dino_x)) +
  geom_point() +
  scale_color_viridis_c() +
  labs(title = "Rawr!",
       subtitle = "Datasaurus says: always visualize your data.",
       color = "Dino color")
```

```{r}
plot_datasaurus_legend
```

### Moving the legend

In this exercise, move the legend to the bottom of the plot.

Refer to [section 11.6.1](https://ggplot2-book.org/scale-colour.html#legend-layout) for this and the next few exercises on legend positioning.

[section 18.4.3](https://ggplot2-book.org/polishing.html#legend-elements)

```{r}
plot_datasaurus_legend +
  theme(legend.position = "bottom")
```

```{r legend-pos-bottom, exercise = TRUE, exercise.setup = "make-plot-datasaurus-legend"}
plot_datasaurus_legend
```

In this exercise, remove the legend from the plot (while keeping the color mapping intact).

```{r}
plot_datasaurus_legend +
  theme(legend.position = "none")
```

```{r legend-pos-none, exercise = TRUE, exercise.setup = "make-plot-datasaurus-legend"}
plot_datasaurus_legend
```

In this exercise, move the legend inside the plot, to the top right-hand corner. You will need to use two arguments in conjunction to make the legend align properly.

Refer to the examples at the end of section 11.6.1 of the textbook.

```{r}
plot_datasaurus_legend +
  theme(legend.position = c(1, 1),
        legend.justification = c(1, 1))
```

```{r legend-pos-topright, exercise = TRUE, exercise.setup = "make-plot-datasaurus-legend"}
plot_datasaurus_legend
```

As far as I can tell, the argument `legend.position` (when set as a numeric vector with 2 elements between 0 and 1) controls the placement of the center point of the legend box inside the plot panel, while the argument `legend.justification` controls where the box itself is drawn relative to the center point. If you want to explore this behavior further, try adjusting `legend.position` and `legend.justification` separately. For most uses, though, as long as those two arguments are set to the same value, in-panel legend placement should work fine.

### Making the legend box transparent

The plot from the last exercise illustrates that the legend box does _not_ have a transparent background, but instead the legend background is the same color as the plot background by default. In cases where the legend is plotted over something else, or the background is otherwise not the default color, it's usually easiest to improve plot appearance by removing the legend background to show the plot beneath.

Using the same technique from a previous exercise in the grid line aesthetics section, remove the legend background from the plot. (Leave the legend position/justification where it is, though!)

```{r}
plot_datasaurus_legend +
  theme(legend.position = c(1, 1),
        legend.justification = c(1, 1),
        legend.background = element_blank())
```
